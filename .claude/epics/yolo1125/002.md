---
name: å¯¦ä½œ FastAPI ä¸»ç¨‹å¼èˆ‡ WebSocket é€šè¨Š
status: open
created: 2025-10-30T05:02:17Z
updated: 2025-10-30T05:02:17Z
github: [Will be updated when synced to GitHub]
depends_on: [001]
parallel: false
conflicts_with: []
---

# Task: å¯¦ä½œ FastAPI ä¸»ç¨‹å¼èˆ‡ WebSocket é€šè¨Š

## Description

å»ºç«‹ FastAPI å¾Œç«¯ä¸»ç¨‹å¼ï¼Œå¯¦ä½œ WebSocket é›™å‘é€šè¨Šæ©Ÿåˆ¶ï¼Œè™•ç†å‰ç«¯å‚³ä¾†çš„å½±åƒå½±æ ¼ä¸¦å»ºç«‹åŸºæœ¬ API ç«¯é»ã€‚é€™æ˜¯å‰å¾Œç«¯æºé€šçš„æ ¸å¿ƒï¼Œç‚ºå¾ŒçºŒçš„ AI è¾¨è­˜æœå‹™æä¾›é€šè¨ŠåŸºç¤ã€‚

**æ ¸å¿ƒç›®æ¨™**ï¼š
- å»ºç«‹ FastAPI æ‡‰ç”¨ç¨‹å¼å’ŒåŸºæœ¬è·¯ç”±
- å¯¦ä½œ WebSocket ç«¯é»è™•ç†å³æ™‚å½±åƒä¸²æµ
- å»ºç«‹ API ç«¯é»ï¼ˆå•†å“åˆ—è¡¨ã€çµå¸³ï¼‰
- æä¾›éœæ…‹æª”æ¡ˆæœå‹™ï¼ˆå‰ç«¯ HTML/CSS/JSï¼‰
- å¯¦ä½œ CORS è¨­å®šå’ŒéŒ¯èª¤è™•ç†

## Acceptance Criteria

- [ ] FastAPI æ‡‰ç”¨ç¨‹å¼æˆåŠŸå•Ÿå‹•ï¼ˆ`uvicorn backend.main:app --reload`ï¼‰
- [ ] WebSocket ç«¯é» `/ws` å¯æ¥æ”¶å‰ç«¯é€£ç·š
- [ ] æˆåŠŸæ¥æ”¶å’Œè§£æ Base64 ç·¨ç¢¼çš„å½±åƒå½±æ ¼
- [ ] å¯¦ä½œ GET `/api/products` ç«¯é»å›å‚³å•†å“åˆ—è¡¨
- [ ] å¯¦ä½œ POST `/api/checkout` ç«¯é»è™•ç†çµå¸³è«‹æ±‚
- [ ] éœæ…‹æª”æ¡ˆæœå‹™æ­£å¸¸ï¼ˆå¯å­˜å– `/` é¡¯ç¤º index.htmlï¼‰
- [ ] WebSocket é€£ç·šç‹€æ…‹ç®¡ç†ï¼ˆé€£ç·šã€æ–·ç·šã€éŒ¯èª¤è™•ç†ï¼‰
- [ ] åŸºæœ¬æ—¥èªŒè¨˜éŒ„åŠŸèƒ½

## Technical Details

### FastAPI ä¸»ç¨‹å¼æ¶æ§‹ï¼ˆmain.pyï¼‰

```python
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
import asyncio
import base64
import cv2
import numpy as np
from datetime import datetime
from pathlib import Path

from backend.database import Database
from backend.config import BASE_DIR

# åˆå§‹åŒ– FastAPI
app = FastAPI(
    title="YOLO1125 æ™ºæ…§ç„¡äººå•†åº—",
    description="çµåˆ YOLO ç‰©å“è¾¨è­˜èˆ‡äººè‡‰è­˜åˆ¥çš„æ™ºæ…§çµå¸³ç³»çµ±",
    version="1.0.0"
)

# CORS è¨­å®šï¼ˆæœ¬åœ°é–‹ç™¼ï¼‰
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# é€£ç·šç®¡ç†
class ConnectionManager:
    def __init__(self):
        self.active_connections: dict[str, WebSocket] = {}
        self.sessions: dict[str, dict] = {}  # session_id: {user_id, cart, ...}

    async def connect(self, websocket: WebSocket, session_id: str):
        await websocket.accept()
        self.active_connections[session_id] = websocket
        self.sessions[session_id] = {
            "user_id": None,
            "cart": [],
            "connected_at": datetime.utcnow()
        }
        print(f"âœ… WebSocket é€£ç·š: {session_id}")

    def disconnect(self, session_id: str):
        if session_id in self.active_connections:
            del self.active_connections[session_id]
        if session_id in self.sessions:
            del self.sessions[session_id]
        print(f"âŒ WebSocket æ–·ç·š: {session_id}")

    async def send_message(self, session_id: str, message: dict):
        if session_id in self.active_connections:
            websocket = self.active_connections[session_id]
            await websocket.send_json(message)

    def get_session(self, session_id: str):
        return self.sessions.get(session_id)

manager = ConnectionManager()

# å•Ÿå‹•äº‹ä»¶
@app.on_event("startup")
async def startup_event():
    """æ‡‰ç”¨ç¨‹å¼å•Ÿå‹•æ™‚åˆå§‹åŒ–"""
    print("ğŸš€ å•Ÿå‹• YOLO1125 ç³»çµ±...")
    Database.connect()
    print("âœ… ç³»çµ±å•Ÿå‹•å®Œæˆ")

@app.on_event("shutdown")
async def shutdown_event():
    """æ‡‰ç”¨ç¨‹å¼é—œé–‰æ™‚æ¸…ç†è³‡æº"""
    print("ğŸ›‘ é—œé–‰ç³»çµ±...")
    Database.close()
    print("âœ… ç³»çµ±å·²é—œé–‰")

# æ ¹è·¯ç”±
@app.get("/", response_class=HTMLResponse)
async def root():
    """æä¾›å‰ç«¯ HTML"""
    html_path = BASE_DIR / "frontend" / "index.html"
    if html_path.exists():
        return HTMLResponse(content=html_path.read_text(encoding="utf-8"))
    else:
        return HTMLResponse(content="<h1>å‰ç«¯æª”æ¡ˆä¸å­˜åœ¨</h1>", status_code=404)

# API è·¯ç”±
@app.get("/api/products")
async def get_products():
    """å–å¾—å•†å“åˆ—è¡¨"""
    try:
        db = Database.get_db()
        products = list(db.products.find({}, {"_id": 0}))
        return JSONResponse(content={"products": products})
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"å–å¾—å•†å“å¤±æ•—: {str(e)}")

@app.post("/api/checkout")
async def checkout(data: dict):
    """è™•ç†çµå¸³"""
    try:
        session_id = data.get("session_id")
        session = manager.get_session(session_id)

        if not session or not session.get("user_id"):
            raise HTTPException(status_code=400, detail="ä½¿ç”¨è€…æœªç™»å…¥")

        # é€™è£¡æœƒåœ¨ Task 007 å¯¦ä½œå®Œæ•´é‚è¼¯
        # ç›®å‰å…ˆå›å‚³æˆåŠŸè¨Šæ¯
        return JSONResponse(content={
            "success": True,
            "message": "çµå¸³æˆåŠŸ",
            "transaction_id": "temp_id"
        })

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"çµå¸³å¤±æ•—: {str(e)}")

# WebSocket è·¯ç”±
@app.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    """WebSocket ç«¯é»è™•ç†å³æ™‚é€šè¨Š"""
    await manager.connect(websocket, session_id)

    try:
        while True:
            # æ¥æ”¶è¨Šæ¯
            data = await websocket.receive_json()
            message_type = data.get("type")

            if message_type == "frame":
                # è™•ç†å½±åƒå½±æ ¼
                await handle_frame(session_id, data)

            elif message_type == "ping":
                # å¿ƒè·³æª¢æ¸¬
                await manager.send_message(session_id, {"type": "pong"})

            elif message_type == "cart_remove":
                # ç§»é™¤è³¼ç‰©è»Šå•†å“
                await handle_cart_remove(session_id, data)

            else:
                print(f"âš ï¸ æœªçŸ¥è¨Šæ¯é¡å‹: {message_type}")

    except WebSocketDisconnect:
        manager.disconnect(session_id)
    except Exception as e:
        print(f"âŒ WebSocket éŒ¯èª¤: {e}")
        manager.disconnect(session_id)

async def handle_frame(session_id: str, data: dict):
    """è™•ç†å½±åƒå½±æ ¼"""
    try:
        # è§£ç¢¼ Base64 å½±åƒ
        frame_data = data.get("frame")
        if not frame_data:
            return

        # ç§»é™¤ data:image/jpeg;base64, å‰ç¶´
        if "," in frame_data:
            frame_data = frame_data.split(",")[1]

        # Base64 è§£ç¢¼
        image_bytes = base64.b64decode(frame_data)
        nparr = np.frombuffer(image_bytes, np.uint8)
        frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)

        if frame is None:
            print("âš ï¸ å½±åƒè§£ç¢¼å¤±æ•—")
            return

        # é€™è£¡æœƒåœ¨å¾ŒçºŒä»»å‹™ä¸­åŠ å…¥ YOLO å’Œäººè‡‰è­˜åˆ¥
        # ç›®å‰å…ˆç™¼é€ç¢ºèªè¨Šæ¯
        await manager.send_message(session_id, {
            "type": "frame_received",
            "timestamp": datetime.utcnow().isoformat()
        })

    except Exception as e:
        print(f"âŒ è™•ç†å½±æ ¼éŒ¯èª¤: {e}")

async def handle_cart_remove(session_id: str, data: dict):
    """è™•ç†ç§»é™¤è³¼ç‰©è»Šå•†å“"""
    try:
        item_index = data.get("index")
        session = manager.get_session(session_id)

        if session and 0 <= item_index < len(session["cart"]):
            removed_item = session["cart"].pop(item_index)
            await manager.send_message(session_id, {
                "type": "cart_updated",
                "cart": session["cart"]
            })
            print(f"ğŸ—‘ï¸ ç§»é™¤å•†å“: {removed_item.get('name')}")

    except Exception as e:
        print(f"âŒ ç§»é™¤è³¼ç‰©è»Šå•†å“éŒ¯èª¤: {e}")

# æ›è¼‰éœæ…‹æª”æ¡ˆ
app.mount("/static", StaticFiles(directory=str(BASE_DIR / "frontend" / "static")), name="static")

# ä¸»ç¨‹å¼å…¥å£
if __name__ == "__main__":
    uvicorn.run(
        "backend.main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )
```

### WebSocket è¨Šæ¯æ ¼å¼

**å‰ç«¯ â†’ å¾Œç«¯**ï¼š
```javascript
// å½±åƒå½±æ ¼
{
  "type": "frame",
  "frame": "data:image/jpeg;base64,/9j/4AAQ...",
  "timestamp": "2025-10-30T05:00:00Z"
}

// å¿ƒè·³
{
  "type": "ping"
}

// ç§»é™¤è³¼ç‰©è»Šå•†å“
{
  "type": "cart_remove",
  "index": 0
}
```

**å¾Œç«¯ â†’ å‰ç«¯**ï¼š
```javascript
// äººè‡‰è­˜åˆ¥çµæœ
{
  "type": "face_detected",
  "user": {
    "id": "user_id",
    "name": "å¼µä¸‰",
    "phone": "0912345678"
  }
}

// å•†å“è­˜åˆ¥çµæœ
{
  "type": "product_detected",
  "product": {
    "id": "product_id",
    "name": "å…ƒç¿ èŒ¶",
    "price": 150,
    "yolo_class_id": 0
  }
}

// è³¼ç‰©è»Šæ›´æ–°
{
  "type": "cart_updated",
  "cart": [
    {"product_id": "...", "name": "å…ƒç¿ èŒ¶", "quantity": 2, "price": 150}
  ],
  "total": 300
}

// å¿ƒè·³å›æ‡‰
{
  "type": "pong"
}
```

### éŒ¯èª¤è™•ç†

```python
from fastapi import Request
from fastapi.responses import JSONResponse

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """å…¨åŸŸéŒ¯èª¤è™•ç†"""
    print(f"âŒ éŒ¯èª¤: {exc}")
    return JSONResponse(
        status_code=500,
        content={"error": str(exc)}
    )
```

## Dependencies

- [ ] Task 001 å®Œæˆï¼ˆå°ˆæ¡ˆçµæ§‹å’Œè³‡æ–™åº«è¨­å®šï¼‰
- [ ] FastAPI å’Œç›¸é—œå¥—ä»¶å·²å®‰è£
- [ ] MongoDB æœå‹™é‹è¡Œä¸­

## Effort Estimate

- **Size**: M (Medium)
- **Hours**: 4-6 å°æ™‚
- **Parallel**: falseï¼ˆä¾è³´ Task 001ï¼‰

**æ™‚é–“åˆ†é…**ï¼š
- FastAPI åŸºæœ¬è¨­å®šï¼š1 å°æ™‚
- WebSocket å¯¦ä½œï¼š2 å°æ™‚
- API ç«¯é»å¯¦ä½œï¼š1 å°æ™‚
- é€£ç·šç®¡ç†å’ŒéŒ¯èª¤è™•ç†ï¼š1 å°æ™‚
- æ¸¬è©¦å’Œé™¤éŒ¯ï¼š1-2 å°æ™‚

## Definition of Done

- [ ] åŸ·è¡Œ `python backend/main.py` æˆåŠŸå•Ÿå‹•æœå‹™
- [ ] ç€è¦½å™¨é–‹å•Ÿ `http://localhost:8000` å¯çœ‹åˆ°å‰ç«¯é é¢ï¼ˆå³ä½¿å…§å®¹ç°¡é™‹ï¼‰
- [ ] ä½¿ç”¨ WebSocket æ¸¬è©¦å·¥å…·å¯é€£ç·šè‡³ `ws://localhost:8000/ws/test_session`
- [ ] ç™¼é€æ¸¬è©¦ JSON è¨Šæ¯æ”¶åˆ°å›æ‡‰
- [ ] GET `/api/products` å›å‚³å•†å“åˆ—è¡¨ï¼ˆåŒ…å«å…ƒç¿ èŒ¶å’Œåˆ†è§£èŒ¶ï¼‰
- [ ] POST `/api/checkout` æ¥å—è«‹æ±‚ä¸¦å›å‚³è¨Šæ¯ï¼ˆå³ä½¿åŠŸèƒ½æœªå®Œæ•´ï¼‰
- [ ] æ—¥èªŒæ­£ç¢ºé¡¯ç¤ºé€£ç·šã€æ–·ç·šå’Œè¨Šæ¯è™•ç†
- [ ] ç„¡æ˜é¡¯è¨˜æ†¶é«”æ´©æ¼ï¼ˆé•·æ™‚é–“é‹è¡Œç©©å®šï¼‰
- [ ] éŒ¯èª¤æƒ…æ³æœ‰é©ç•¶è™•ç†ï¼ˆä¾‹å¦‚ç„¡æ•ˆçš„ Base64 è³‡æ–™ï¼‰
